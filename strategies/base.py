"""
Abstract base strategy class and TradeSignal dataclass.

All trading strategies inherit from BaseStrategy and implement
scan() and execute() methods. The run_once() method provides
the standard scan → filter → execute pipeline.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field

from data.market_scanner import MarketScanner
from data.orderbook import OrderBookManager
from data.price_feed import PriceFeed
from execution.fee_calculator import calculate_fee
from execution.order_manager import OrderManager
from execution.position_tracker import PositionTracker
from kalshi.client import KalshiClient
from risk.risk_manager import RiskManager
from utils.logger import get_logger

log = get_logger("strategies.base")


@dataclass
class TradeSignal:
    """A signal to place a trade, generated by a strategy."""

    strategy: str           # "momentum_scalp", "market_maker", "cross_strike_arb"
    ticker: str             # Market ticker (e.g., "KXBTC-26FEB14-T70000")
    side: str               # "yes" or "no"
    action: str             # "buy" or "sell"
    price_cents: int        # Limit price in cents
    contracts: int          # Number of contracts
    edge_cents: float       # Expected edge in cents after fees
    confidence: float       # 0.0 to 1.0
    post_only: bool = False # Use maker order?
    reason: str = ""        # Human-readable explanation
    event_ticker: str = ""  # Parent event ticker (for risk checks)


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Subclasses must implement scan() and execute().
    The run_once() method provides the standard pipeline:
        scan → risk filter → execute
    """

    def __init__(
        self,
        client: KalshiClient,
        price_feed: PriceFeed,
        risk_manager: RiskManager,
        order_manager: OrderManager,
        position_tracker: PositionTracker,
        orderbook_manager: OrderBookManager,
        market_scanner: MarketScanner,
    ) -> None:
        self.client = client
        self.price_feed = price_feed
        self.risk_manager = risk_manager
        self.order_manager = order_manager
        self.position_tracker = position_tracker
        self.orderbook = orderbook_manager
        self.market_scanner = market_scanner

    @property
    @abstractmethod
    def name(self) -> str:
        """Strategy name used in logging and signal attribution."""
        ...

    @abstractmethod
    async def scan(self) -> list[TradeSignal]:
        """
        Scan for trading opportunities.

        Returns:
            List of TradeSignal objects representing potential trades.
        """
        ...

    @abstractmethod
    async def execute(self, signals: list[TradeSignal]) -> None:
        """
        Execute approved trade signals.

        Args:
            signals: List of risk-approved TradeSignal objects.
        """
        ...

    async def run_once(self) -> None:
        """
        Single iteration of the strategy pipeline:
        1. Scan for opportunities
        2. Filter through risk manager
        3. Execute approved signals
        """
        try:
            signals = await self.scan()

            if not signals:
                log.info("[%s] Scan complete — no signals", self.name)
                return

            log.info("[%s] Found %d signal(s):", self.name, len(signals))
            for sig in signals:
                log.info(
                    "  → %s %s %s @ $%.2f, edge=%.1fc, qty=%d",
                    sig.side, sig.ticker, sig.strategy, sig.price,
                    sig.edge * 100 if sig.edge else 0, sig.quantity,
                )

            approved = self.risk_manager.filter_signals(signals)

            if not approved:
                log.info("[%s] %d signal(s) blocked by risk manager", self.name, len(signals))
                return

            log.info("[%s] Executing %d approved signal(s)", self.name, len(approved))
            await self.execute(approved)

        except Exception:
            log.exception("[%s] Error in run_once", self.name)
